{"mode":"Text","textContent":"/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       main.cpp                                                  */\n/*    Author:       james                                                     */\n/*    Created:      Tue Dec 29 2020                                           */\n/*    Description:  V5 Default clawbot drive code                             */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\n// Assign generic motor to more useful names here\n// We use references\nmotor   &LeftDrive1  = Motor1;\nmotor   &RightDrive1 = Motor2;\nmotor   &LeftDrive2  = Motor9;\nmotor   &RightDrive2 = Motor10;\n\n// Arm and claw motors will have brake mode set to hold\n// Claw motor will have max torque limited\nmotor   &ClawMotor   = Motor3;\nmotor   &ArmMotor    = Motor8;\n\n// Options for drive control, the same optiona as V5 default drive code\ntypedef enum _drive_mode {\n    left_arcade,\n    dual_stick,\n    split_arcade,\n    right_arcade\n} drive_mode_t;\n\n// Choose your drive mode here\nconst drive_mode_t drive_mode = left_arcade;\n\n// Max motor speed (percent) for motors controlled by buttons\nconst int32_t maxSpeed = 50;\n\n/*----------------------------------------------------------------------------*/\n/** @brief  Drive task                                                        */\n/*----------------------------------------------------------------------------*/\n//\n// All motors are controlled from this function which is run as a separate thread\n//\nvoid\ndriveTask() {\n    int32_t drive_left  = 0;\n    int32_t drive_right = 0;\n\n    // setup the claw motor\n    ClawMotor.setMaxTorque( 25, percent );\n    ClawMotor.setStopping( hold );\n\n    // setup the arm motor\n    ArmMotor.setStopping( hold );\n\n    // loop forever\n    while( true ) {\n        // buttons\n        // Three values, max, 0 and -max.\n        //\n        int32_t drive_m_3 = (Controller1.ButtonL1.pressing() - Controller1.ButtonL2.pressing()) * maxSpeed;\n        int32_t drive_m_4 = (Controller1.ButtonRight.pressing() - Controller1.ButtonLeft.pressing()) * maxSpeed;\n        int32_t drive_m_5 = (Controller1.ButtonUp.pressing() - Controller1.ButtonDown.pressing()) * maxSpeed;\n        int32_t drive_m_6 = (Controller1.ButtonA.pressing() - Controller1.ButtonY.pressing()) * maxSpeed;\n        int32_t drive_m_7 = (Controller1.ButtonX.pressing() - Controller1.ButtonB.pressing()) * maxSpeed;\n        int32_t drive_m_8 = (Controller1.ButtonR1.pressing() - Controller1.ButtonR2.pressing()) * maxSpeed;\n        \n        // use limit switches on motors 3 and 8\n        if( ( LimitSwitch3F.pressing() && (drive_m_3 > 0)) || ( LimitSwitch3R.pressing() && (drive_m_3 < 0)) )\n            drive_m_3  = 0;\n        if( ( LimitSwitch8F.pressing() && (drive_m_8 > 0)) || ( LimitSwitch8R.pressing() && (drive_m_8 < 0)) )\n            drive_m_8  = 0;\n\n        // Various choices for arcade or tank drive\n        switch( drive_mode ) {\n            case left_arcade:\n              drive_left  =  Controller1.Axis3.position() + Controller1.Axis4.position();\n              drive_right =  Controller1.Axis3.position() - Controller1.Axis4.position();\n              break;\n            case dual_stick:\n              drive_left  =  Controller1.Axis3.position();\n              drive_right =  Controller1.Axis2.position();\n              break;\n            case split_arcade:\n              drive_left  =  Controller1.Axis3.position() + Controller1.Axis1.position();\n              drive_right =  Controller1.Axis3.position() - Controller1.Axis1.position();\n              break;\n            case right_arcade:\n              drive_left  =  Controller1.Axis2.position() + Controller1.Axis1.position();\n              drive_right =  Controller1.Axis2.position() - Controller1.Axis1.position();\n              break;\n            default:\n              break;\n        }\n\n        // threshold the variable channels so the drive does not\n        // move if the joystick axis does not return exactly to 0\n        const int deadband = 15;\n        if( abs(drive_left ) < deadband ) drive_left  = 0;\n        if( abs(drive_right) < deadband ) drive_right = 0;\n\n        // Now send all drive values to motors\n\n        // The drivetrain\n        LeftDrive1.spin( forward, drive_left, percent );\n        LeftDrive2.spin( forward, drive_left, percent );\n        RightDrive1.spin( forward, drive_right, percent );\n        RightDrive2.spin( forward, drive_right, percent );\n\n        // and all the auxilary motors\n        Motor3.spin( forward, drive_m_3, percent );\n        Motor4.spin( forward, drive_m_4, percent );\n        Motor5.spin( forward, drive_m_5, percent );\n        Motor6.spin( forward, drive_m_6, percent );\n        Motor7.spin( forward, drive_m_7, percent );\n        Motor8.spin( forward, drive_m_8, percent );\n\n        // No need to run too fast\n        this_thread::sleep_for(10);\n    }\n}\n\n// define some more colors\nconst vex::color grey((uint32_t)0x202020);\nconst vex::color dgrey((uint32_t)0x2F4F4F);\nconst vex::color lblue((uint32_t)0x303060);\nconst vex::color lred((uint32_t)0x603030);\n\n/*-----------------------------------------------------------------------------*/\n/** @brief      Display data for one motor                                     */\n/*-----------------------------------------------------------------------------*/\nvoid\ndisplayMotorData( motor &m ) {\n  int ypos = 0;\n  int xpos = m.index() * 48;\n\n  // There's no C++ API to get motor command value, use C API, this returns rpm\n  int v1  = vexMotorVelocityGet(m.index());\n\n  // The actual velocity of the motor in rpm\n  int v2  = m.velocity(velocityUnits::rpm);\n\n  // The position of the motor internal encoder in revolutions\n  double pos = m.position(rotationUnits::rev);\n\n  // Motor current in Amps    \n  double c1 = m.current();\n\n  // Motor temperature\n  double t1 = m.temperature(temperatureUnits::celsius);\n\n  Brain.Screen.setFont( mono15 );\n\n  // background color based on\n  // device and whether it's left, right or other motor\n  if( !m.installed() ) {\n    // no motor\n    Brain.Screen.setFillColor( grey );\n  }\n  else  \n  if( m.index() == LeftDrive1.index() || m.index() == LeftDrive2.index() ) {\n    Brain.Screen.setFillColor( lblue );\n  }\n  else  \n  if( m.index() == RightDrive1.index() || m.index() == RightDrive2.index() ) {\n    Brain.Screen.setFillColor( lred );\n  }\n  else {\n    Brain.Screen.setFillColor( dgrey );\n  }\n  \n  // Draw outline for motor info\n  Brain.Screen.setPenColor( white  );\n  int w = (m.index() < 9) ? 49 : 48;\n  Brain.Screen.drawRectangle( xpos, ypos, w, 79 );\n  \n  // no motor, then return early\n  if( !m.installed() ) {\n    Brain.Screen.printAt( xpos+15, ypos+30, true, \"NC\" );\n    return;\n  }\n\n  // Show commanded speed\n  if( v1 != 0 )\n    Brain.Screen.setPenColor( green );\n  else\n    Brain.Screen.setPenColor( white );\n  Brain.Screen.printAt( xpos+13, ypos+13, true, \"%4d\", v1 );\n\n  // Show actual speed\n  Brain.Screen.setPenColor( yellow  );\n  Brain.Screen.printAt( xpos+13, ypos+30, true, \"%4d\", v2 );\n\n  // Show position\n  Brain.Screen.printAt( xpos+5, ypos+45, true, \"%5.1f\", pos );\n\n  // Show current\n  Brain.Screen.printAt( xpos+5, ypos+60, true, \"%4.1fA\", c1 );\n\n  // Show temperature\n  Brain.Screen.printAt( xpos+5, ypos+75, true, \"%4.0fC\", t1 );\n\n  Brain.Screen.setPenColor( white  );\n  Brain.Screen.drawLine( xpos, ypos+14, xpos+48, ypos+14);  \n}\n\n/*----------------------------------------------------------------------------*/\n/** @brief  Display task - show some useful motor data                        */\n/*----------------------------------------------------------------------------*/\nvoid\ndisplayTask() {\n    Brain.Screen.setFont( prop40 );\n    Brain.Screen.setPenColor( red );\n    Brain.Screen.printAt( 90, 160, \"TEST DRIVE CODE\");\n\n    motor *motors[] = { &Motor1, \n                        &Motor2,\n                        &Motor3,\n                        &Motor4,\n                        &Motor5,\n                        &Motor6,\n                        &Motor7,\n                        &Motor8,\n                        &Motor9,\n                        &Motor10\n                      };\n                      \n    while( true ) {\n      for( int i=PORT1;i<=PORT10;i++) {\n        displayMotorData( *motors[i] );\n      }\n\n      // display using back buffer, stops flickering\n      Brain.Screen.render();\n\n      this_thread::sleep_for(10);\n    }\n}\n\nint main() {\n    // Run the drive code\n    thread drive( driveTask );\n\n    // Run the display code\n    thread display( displayTask );\n\n    // main just loops here until the program is terminated\n    while( true ) {\n      this_thread::sleep_for(100);\n    }\n}\n","textLanguage":"cpp","rconfig":[{"port":[1],"name":"Motor1","customName":false,"deviceType":"Motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[2],"name":"Motor2","customName":false,"deviceType":"Motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[3],"name":"Motor3","customName":false,"deviceType":"Motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[4],"name":"Motor4","customName":false,"deviceType":"Motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[5],"name":"Motor5","customName":false,"deviceType":"Motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[6],"name":"Motor6","customName":false,"deviceType":"Motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[7],"name":"Motor7","customName":false,"deviceType":"Motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[8],"name":"Motor8","customName":false,"deviceType":"Motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[9],"name":"Motor9","customName":false,"deviceType":"Motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[10],"name":"Motor10","customName":false,"deviceType":"Motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[1],"name":"LimitSwitch3F","customName":true,"deviceType":"LimitSwitch","setting":{"id":"partner"},"triportSourcePort":22},{"port":[2],"name":"LimitSwitch3R","customName":true,"deviceType":"LimitSwitch","setting":{"id":"partner"},"triportSourcePort":22},{"port":[3],"name":"LimitSwitch8F","customName":true,"deviceType":"LimitSwitch","setting":{"id":"partner"},"triportSourcePort":22},{"port":[4],"name":"LimitSwitch8R","customName":true,"deviceType":"LimitSwitch","setting":{"id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"","appVersion":"","fileFormat":"1.0.0","icon":""}